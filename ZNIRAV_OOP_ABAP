**&---------------------------------------------------------------------*
**& Report ZNIRAV_OOP_ABAP
**&---------------------------------------------------------------------*
**&
**&---------------------------------------------------------------------*
REPORT znirav_oop_abap.
** CLASS HAS 2 SECTION ONE DECLERATION PART OTHER IMPLEMENTATION, IN IT CLASS HAS 3 SECTIONS PUBLIC, PRIVATE, PROTECTED SECTION
** BUT CLASS SHOULD HAVE ATLEAST ONE SECTION DEFINED.
*
**   THIS IS CLASS DEFINATION PART ANY METHOD, DATA MEMBERS CONSTANTS ARE DECLEARED HERE.
*CLASS myClass DEFINITION.
*
**  THIS IS PUBLIC SECTION MEANING IT WILL CREATE GLOBAL CLASS, FOLLOWING THIS WE ALSO HAVE PRIVATE, PROTECTED.
*  PUBLIC SECTION.
*
*
**  VARIABLES DEFINED WITH "CLASS-DATA"  ARE STATIC DATA MEMBERS WHICH CAN BE CALLED BY INSTANCE OR CLASS.
*    class-DATA :name TYPE string,
*     surname TYPE String.
*
*
**  VARIABLES DEFINED WITH "DATA"  ARE INSTANCE DATA MEMBERS WHICH CAN BE CALLED ONLY BY INSTANCE.
*    DATA x TYPE bool.
*
*
**   METHODS DECLARED BY "METHODS" ARE INSTANCE METHOD WHICH CAN ONLY CALLED BY INSTANCE.
**   OBJECT IS REFFERED AS INSTANCE.
*    METHODS Fetch_Name
*      IMPORTING get_name TYPE string
*      EXPORTING set_name TYPE string.
*
*
**    METHODS DECLARED BY "CLASS-METHODS" ARE STATIC METHOD WHICH CAN BE CALLED BY CLASS NAME AND INSTANCE BOTH.
*    CLASS-METHODS Fetch_Surname
*      IMPORTING get_surname TYPE string
*      CHANGING  full_name   TYPE string.
*
*ENDCLASS.
*
*
*
** CLASS ALSO HAVE IMPLEMENTATION SECTION, WHICH IS ONLY REQUIRED IF WE HAVE DECLARED METHODS IN DEFINITION PART, ELSE ITS FINE TO OMIT IT.
*CLASS myclass IMPLEMENTATION.
*  METHOD Fetch_Name.
*    name = get_name.
*    set_name = name.
*  ENDMETHOD.
*
*  METHOD fetch_surname.
*    surname = get_surname.
*   CONCATENATE  name surname INTO  full_name SEPARATED BY space.
*   full_name = 'Name'.
*    ENDMETHOD.
*ENDCLASS.
*
*
** "START-OF-SELECTION WHICH IS EXECUTED AFTER USER INPUT"
*START-OF-SELECTION.
** LOCAL VARIABLES.
*  DATA myname TYPE string.
*
**  OBJECT DECLEARTION (WE DIDN'T CREATE IT, IT'S JUST DECLARED IF WE WANT TO USE THIS OBJECT CREATE IT WITH IT'S RESPECTIVE CLASS ) .
*  DATA myObj TYPE REF TO myclass.
*
**  OBJECT CREATION.
*  myobj = NEW #( ).
*
**  INSTANCE METHOD CALLING
*  myobj->Fetch_Name(
*  EXPORTING get_name = 'Nirav'
*  IMPORTING set_name = myname ).
*
**  STATIC METHOD CALLING
*  myclass=>fetch_surname( EXPORTING get_surname = 'Patel'
*                          CHANGING full_name = myname ).
*
*  WRITE:/ myname.


**&---------------------------------------------------------------------*
**& OPTIONAL AND DEFAULT PARAMETERS.
**&---------------------------------------------------------------------*
**&
**&---------------------------------------------------------------------*

*  OPTIONAL PARAMETERS ARE OPTIONAL IF NOT PASSED IT WILL BE INITIAL AND WHEN DEFAULT VALUE IS GIVEN, IF VALUE IS NOT PASSED IT WILL JUST USE DEFAULT VALUE

*CLASS opt_Def_parameters DEFINITION.
*
*  PUBLIC SECTION.
*
**  METHOD DECLARED WITH OPTIONAL AND DEFAULT PARAMETER.
*    METHODS sumation
*      IMPORTING num1 TYPE i OPTIONAL
*                num2 TYPE i OPTIONAL
*                num3 TYPE i DEFAULT 10.
*
*ENDCLASS.
*
*
*CLASS opt_def_parameters IMPLEMENTATION.
*
*  METHOD sumation.
*
**   "IS SUPPLIED" IT WILL JUST CHECK IF THE PARAMETER IS PASSED.IF IT IS IT WILL RETURN TURE ELSE FALSE.
*    IF num1 IS SUPPLIED.
*      WRITE: / |Num1 is supplied { num1 } |.
*    ELSE.
*      WRITE: / |Num1 is not supplied|.
*    ENDIF.
*    IF num2 IS SUPPLIED.
*      WRITE: / |Num2 is supplied { num2 } |.
*    ELSE.
*      WRITE: / |Num2 is not supplied|.
*    ENDIF.
*    IF num3 IS NOT INITIAL.
*      WRITE: / |Num3 is Not Initial, it contains default, value is { num3 } |.
*    ELSE.
*      WRITE: / |Num3 is inital / not supplied|.
*    ENDIF.
*  ENDMETHOD.
*ENDCLASS.

*START-OF-SELECTION.

*  DATA myobj1 TYPE REF TO opt_def_parameters.
*  myobj1 = NEW #( ).

*  myobj1->sumation( NUM1 = 999 ).



**&---------------------------------------------------------------------*
**& PREFERRED PARAMETERS.
**&---------------------------------------------------------------------*
**&
**&---------------------------------------------------------------------*

*   WHEN WE HAVE MULTIPLE OPTIONAL PARAMETERS AND WE PASS THE PARAMETER VALUE WITHOUT SPECIFYING THE FORMAL PARAMETER NAME THEN IT WILL PASS THE VALUE TO
*   PREFERRED PARAMETER ( IF GIVEN ELSE IT WILL RAISE ERROR ASKING TO PROVIDE FORMAL PARAMETER NAME) .

*CLASS preferred_parameter DEFINITION.
*  PUBLIC SECTION.
*
**  HERE WE HAVE PREFERRED PARAMETER IS NUM3 SO IF WE DON'T GIVE NAME FORMAL PARAMETER NAME THEN IT WILL PASS THE GIVEN VALUE IN NUM3.
*    METHODS pref_Params
*      IMPORTING num1 TYPE i OPTIONAL
*                num2 TYPE i OPTIONAL
*                num3 TYPE i OPTIONAL
*                  PREFERRED PARAMETER num3.
*ENDCLASS.
*
*CLASS preferred_parameter IMPLEMENTATION.
*
*  METHOD pref_params.
*    IF num1 IS SUPPLIED.
*      WRITE: / |Num1 is supplied { num1 } |.
*    ELSE.
*      WRITE: / |Num1 is not supplied|.
*    ENDIF.
*    IF num2 IS SUPPLIED.
*      WRITE: / |Num2 is supplied { num2 } |.
*    ELSE.
*      WRITE: / |Num2 is not supplied|.
*    ENDIF.
*    IF num3 IS SUPPLIED.
*      WRITE: / |Num3 is Supplied { num3 } |.
*    ELSE.
*      WRITE: / |Num3 is not supplied|.
*    ENDIF.
*  ENDMETHOD.
*ENDCLASS.
*
*START-OF-SELECTION.
*
**  THIS IS OBJECT DECLERATION AND THEN CREATION IN SECOND LINE.
**  DATA  myobj3  TYPE REF TO preferred_parameter.
**  myobj3 = NEW #( ).
*
** THIS IS INLINE OBJECT DELECRATION AND CREATION.
*  DATA(myobj3) = NEW preferred_parameter( ).
*
***  HERE I'VE PASSED VALUE WITHOUT GIVING FORMAL PARAMETER NAME SO IT WILL JUST ASSIGN THE VALUE 100 TO PREFERRED.
*  myobj3->pref_params( 100 ).




**&---------------------------------------------------------------------*
**& Constructor.
**&---------------------------------------------------------------------*
**&
**&---------------------------------------------------------------------*

*-------------------------- DEFINITION ---------------------------------*

* CONSTRUCTOR IS JUST SPECIAL METHOD WHICH IS CALLED AUTOMATICALLY UPON CREATING OBJECT OF ITS RESPECTIVE CLASS( SAME CONCEPT OF JAVA ).
* NOW CONSTRUCTOR ARE OF 2 TYPES, STATIC AND INSTANCE. THERE CAN ONLY BE ONE STATIC AND INSTANCE CONSTRUCTOR THROUGHOUT THE CLASS.
* CONSTRUCTOR NAMES ARE FIXED, INSTANCE CONSTRUCTOR IS NAME "constructor" and static constructor is named "class_constructor".
* SO THIS WAY IT IS IDENTIFIED IN COMPARE WITH OTHER METHODS.


*CLASS Demo_Constructor DEFINITION.
*  PUBLIC SECTION.
*
**  THIS IS INSTANCE CONSTRUCTOR IS DECLARED USING "METHODS" WHICH CAN ONLY BE DEFINED IN PUBLIC SECTION, AND IT WILL CALLED UPON CREATING OBJECT,
**  IF CREATED 3 OBJECT IT WILL BE CALLED 3 TIMES
**  IT CAN HAVE IMPORTING PARAMETERS AND RAISE EXCEPTIONS.
*    METHODS constructor.
*
** STATIC CONSTRUCTORS ARE DECLARED WITH "CLASS-METHODS", it will only be called when calling the class first time or any instance is created firsttime.
*    CLASS-METHODS class_constructor.
*    CLASS-METHODS test_meth.
*
*ENDCLASS.
*
*
*CLASS demo_constructor IMPLEMENTATION.
*  METHOD test_meth.
*    WRITE:/ 'hello this is test method' .
*  ENDMETHOD.
*  METHOD constructor.
*    WRITE:/' Object Created and static constructor is called automatically '.
*  ENDMETHOD.
*
*  METHOD class_constructor.
*    WRITE:/'Instance constructor'.
*  ENDMETHOD.
*
*ENDCLASS.
*
*START-OF-SELECTION.
*
**   LIKE HERE WHEN "test_meth" IS CALLED II WILL CALL STATIC COUSTRUCTOR BECAUSE IS BEING SED THE CLASS HERE.
*  demo_constructor=>test_meth( ).
*
**  AND HERE I'VE CREATED 3 OBJECT SO INSTANCE CONSTRUCTOR IS BEING CALLED 3 TIMES.
*  DATA(obj) = NEW demo_constructor( ).
*  DATA(obj1) = NEW demo_constructor( ).
*  DATA(obj2) = NEW demo_constructor( ).




**&---------------------------------------------------------------------*
**& Inheritance.
**&---------------------------------------------------------------------*
**&
**&---------------------------------------------------------------------*

** inheritance IS IMPLEMENTED BY "INHERITING FROM class_name", BY INHERITING THE PARENT CLASS CHILD CAN ACCESS ALL ITS METHODS BUT ALSO,
** IT CAN REDEFINE THE METHODS.


**--------------------MyClass-----------------------*
** "myclass1" NORMAL CLASS USED AS PARENT CLASS FURTHER.

*CLASS myclass DEFINITION CREATE PUBLIC.
*  PUBLIC SECTION.
*    METHODS meth1.
*    METHODS meth2.
*ENDCLASS.
*
*CLASS myclass IMPLEMENTATION.
*
*  METHOD meth1.
*    WRITE:/ ' This is Meth1 '.
*  ENDMETHOD.
*
*  METHOD meth2.
*    WRITE:/ ' This is Meth2 '.
*  ENDMETHOD.
*
*ENDCLASS.
*
**--------------------MyClass2-----------------------*
** "myclass2" IS USED AS CHILD CLASS WHICH IS INHERITING "myclass".

*CLASS myclass2 DEFINITION INHERITING FROM myclass.
*  PUBLIC SECTION.
*    METHODS meth3.
*ENDCLASS.
*
*CLASS myclass2 IMPLEMENTATION.
*  METHOD meth3.
*write:' Hello '.
*
*  ENDMETHOD.
*ENDCLASS.
*
*START-OF-SELECTION.
*DATA(obj2) = new myclass2( ).
*
** HERE WE HAVE CALLED "Meth1" USING CHILD CLASS OBJECT.
*write:/ 'This meth1 was called using child class object'.
*obj2->meth1( ).


**----------------------------------------------------------------------------------------------------------------*
**-----------------------------------------------Method Reefinition-----------------------------------------------*
**----------------------------------------------------------------------------------------------------------------*
*
**--------------------Parent Class-----------------------*
*CLASS parent_class DEFINITION.
*  PUBLIC SECTION.
*    METHODS meth4.
*    METHODS meth5.
*ENDCLASS.
*
*CLASS parent_class IMPLEMENTATION.
*  METHOD meth4.
*    WRITE:/ 'this is meth4'.
*  ENDMETHOD.
*  METHOD meth5.
*    WRITE:/ 'this is meth5'.
*  ENDMETHOD.
*ENDCLASS.
*
*
**--------------------Child Class-----------------------*
*CLASS child_class DEFINITION INHERITING FROM parent_class.
*  PUBLIC SECTION.
*  METHODS meth5 REDEFINITION.
*ENDCLASS.
*
*CLASS child_class IMPLEMENTATION.
*METHOD meth5.
*  super->meth5( ).
*  write:/'This is redefined meth5 called from child class'.
*ENDMETHOD.
*ENDCLASS.
*
*START-OF-SELECTION.
*DATA(c_obj) = NEW child_class( ).
*c_obj->meth5( ).


**&---------------------------------------------------------------------*
**& Interface.
**&---------------------------------------------------------------------*
**&
**&---------------------------------------------------------------------*

* INTERFACE IS DEFINED USINF "INTERFACE","ENDINTERFACE", YOU CAN DEFINE ALL CLASS OBJECT EXCEPT CONSTRUCTOR,
* ONE CLASS CAN IMPLEMENT MULTIPLE INTERFACE. CLASS MUCT USE ALL THE METHODS OF IMPLEMENTED "INTERFACE", UNLESS IT FLAGGED.
* INTERFACE CAN BE IMPLEMENTED IN OTHER INTERFACE.

*INTERFACE itrf.
*  METHODS Rectangle_area IMPORTING len  TYPE i
*                                   brth TYPE i.
*ENDINTERFACE.
*
*INTERFACE itrf2.
*  INTERFACES itrf.
*  METHODS Area IMPORTING side_len TYPE i OPTIONAL
*                         height   TYPE i OPTIONAL
*                         pie      TYPE decfloat OPTIONAL
*                         circum   TYPE i OPTIONAL
*                         radius   TYPE i OPTIONAL.
*ENDINTERFACE.


*--------------------MyClass3-----------------------*
*IN "myclass3" IS A SIMPLE EXAMPLE, ONLY ONE INTERFACE IS IMPLEMENTED IN CLASS.


*  CLASS myclass3 DEFINITION.
*    PUBLIC SECTION.
*    DATA: C_len TYPE i,
*          C_brth type i,
*          c_area TYPE i.
*    INTERFACES itrf.
*  ENDCLASS.
*
*  CLASS myclass3 IMPLEMENTATION.
*   METHOD itrf~Rectangle_area.
*     c_len = len.
*     c_brth = brth.
*     c_area = c_len * c_brth.
*     WRITE:/ c_area .
*     ENDMETHOD.
*    ENDCLASS.

*--------------------MyClass4-----------------------*
* IN "myclass4" THERE ARE 2 INTERFACES AND INTERFACE "itrf" IS IMPLEMENTED IN OTHER INTERFACE "itrf2".

*CLASS myclass4 DEFINITION.
*  PUBLIC SECTION.
*    INTERFACES itrf2.
*
**    HERE "ALIASES alias_name FOR method_name" IS USED TO GIVE ALIASE NAME FOR THAT INTERFACE METHOD.
*    ALIASES rect_ar FOR itrf~rectangle_area.
*
*    DATA c2_area TYPE i.
*
*ENDCLASS.
*
*CLASS myclass4 IMPLEMENTATION.
**  ALIAS NAME "rect_ar".
*  METHOD rect_ar.
*    c2_area = len * brth.
*    WRITE:/ | Area of Rectangle is: { c2_area } |.
*  ENDMETHOD.
*  METHOD itrf2~area.
*    IF side_len IS NOT INITIAL.
*      c2_area =  side_len * side_len.
*      WRITE:/ | Area of Square is: { c2_area } |.
*    ENDIF.
*
*    IF pie IS NOT INITIAL.
*      c2_area = pie * radius * radius.
*      WRITE:/ | Area of circle is: { c2_area } |.
*    ENDIF.
*
*    itrf~rectangle_area( len = 10 brth = 20 ).
*
*  ENDMETHOD.
*ENDCLASS.
*
*
*
**--------------------START OF SELECFTION-----------------------*
*START-OF-SELECTION.
*
**--------------------MyClass3-----------------------*
**    DATA(obj4) = NEW myclass3( ).
**    obj4->itrf~Rectangle_area( len = 10 brth = 20 ).
*
**--------------------MyClass4-----------------------*
*DATA(obj5) = NEW myclass4( ).
*obj5->itrf2~area( pie = '3.14' side_len = 10 height = 10 radius = 5  ).




**-----------------------Abstract Method-------------------------*
* WE CAN HAVE ABSTRACT METHOD WHICH CAN ONLY BE IMPLEMENTED BY CHILD CLASS, ITS IMPLEMENTATION IS NOT IN IT'S OWN CLASS.
* ABSTRACT METHOD CAN BE IMPLEMENTED USING "ABSTRACT METHODS" KEYWORD AND CLASS IS IMPLEMENTED BY "ABSTRACT" KEYWORD WHILE DEFINING.

*INTERFACE itrf3.
*  METHODS: meth4,
*           meth5.
*ENDINTERFACE.
*
*CLASS myclass5 DEFINITION ABSTRACT.
*  PUBLIC SECTION.
*    INTERFACES itrf3 ABSTRACT METHODS meth4.
*ENDCLASS.
*
*
***-----------------------myclass5 ( Parent Class )-------------------------*
*CLASS myclass5 IMPLEMENTATION.
*  METHOD itrf3~meth5.
*    WRITE:/ ' Hello this is Method 5 '.
*  ENDMETHOD.
*ENDCLASS.
*
*
***-----------------------myclass6 ( Child Class )-------------------------*
*CLASS myclass6 DEFINITION INHERITING FROM myclass5.
*  PUBLIC SECTION.
*    METHODS itrf3~meth4 REDEFINITION.
*    METHODS itrf3~meth5 REDEFINITION.
*ENDCLASS.
*
*CLASS myclass6 IMPLEMENTATION.
*  METHOD itrf3~meth4.
*    WRITE:/ ' Hello this is Method 4 called from child class of "myclass5" '.
*  ENDMETHOD.
*
*  METHOD itrf3~meth5.
*    super->itrf3~meth5( ).
*    WRITE:/ ' Hello this is redefined Method 5 called from child class of "myclass5" '.
*  ENDMETHOD.
*
*ENDCLASS.
*
*START-OF-SELECTION.
*  DATA(myobj5) = NEW myclass6( ).
*  myobj5->itrf3~meth4( ).
*  myobj5->itrf3~meth5( ).



**-----------------------Final Method-------------------------*

*  FINAL METHODS CANNOT BE REDEFINED IN SUBCLASSES, TO CREATE FINAL METHOD USE "FINAL METHODS" WHILE IMPLEMENTING INTERFACE.
*  FOR CLASS METHODS WHILE DEFINING METHOD USE "FINAL".

*INTERFACE itrf4.
*  METHODS meth6.
*  METHODS meth7.
*ENDINTERFACE.
*
*CLASS myclass7 DEFINITION.
*  PUBLIC SECTION.
*    INTERFACES itrf4 FINAL METHODS meth6.
*    METHODS meth8 FINAL.
*ENDCLASS.
*
*CLASS myclass7 IMPLEMENTATION.
*  METHOD itrf4~meth6.
*    WRITE:/ ' Hello This is Method 6 ' .
*  ENDMETHOD.
*  METHOD itrf4~meth7.
*    WRITE:/ ' Hello This is Method 7 ' .
*  ENDMETHOD.
*  METHOD meth8.
*    WRITE:/ ' Hello This is Method 8 ' .
*  ENDMETHOD.
*ENDCLASS.
*
*CLASS myclass8 DEFINITION INHERITING FROM myclass7.
*  PUBLIC SECTION.
**  IF YOU EXECUTE THIS NEXT LINE IT WILL RAISE AN ERROR "meth6" CANNOT BE REDEFINED.
**  METHODS itrf4~meth6 REDEFINITION.
*    METHODS itrf4~meth7 REDEFINITION.
*ENDCLASS.
*CLASS myclass8 IMPLEMENTATION.
*  METHOD itrf4~meth7.
*    WRITE:/' Hello This is method7 '.
*  ENDMETHOD.
*ENDCLASS.

*START-OF-SELECTION.
*data(myobj6) = NEW myclass8( ).
*myobj6->itrf4~meth7( ).



**------------------------------DATA VALUES-------------------------------*
* DATA VALUES WILL JUST SET THE DEFAULT VALUES TO THE VARIABLES IN INTERFACE WHILE IMPLEMENTING INTERFACE IN ANY CLASS.

*INTERFACE itrf5.
*  data: var1 TYPE i,
*        var2 TYPE i.
*  METHODS meth8.
*
*  ENDINTERFACE.
*
*CLASS myclass9 DEFINITION.
*  PUBLIC SECTION.
*  DATA var3 TYPE i.
*  INTERFACES itrf5 DATA VALUES var1 = 100 var2 = 200.
*ENDCLASS.
*CLASS myclass9 IMPLEMENTATION.
*  METHOD itrf5~meth8.
*    itrf5~var1 = 10.
*    itrf5~var2 = 30.
*    var3 = itrf5~var1 + itrf5~var2.
*    write:/ | Total is { var3 } | .
*  ENDMETHOD.
*ENDCLASS.
*
*
*START-OF-SELECTION.
*DATA(myobj7) = NEW myclass9( ).
*myobj7->itrf5~meth8( ).



**&---------------------------------------------------------------------*
**& Test Class.
**&---------------------------------------------------------------------*
**&
**&---------------------------------------------------------------------*

